source ~/dotfiles/python-scripts/fastgdb_definitions
alias .P="source ~/.pwn_funcs"
alias .pwn="source ~/.pwn_funcs"

alias gdbpwn='gdb -x $(ls -Art /tmp/pwn*.gdb | tail -n 1)'
alias gmul='echorun "gdb-multiarch -ex \"target remote localhost:1234\" -ex pwn"'
alias gefmul='echorun "gdb-multiarch -ex \"target remote localhost:1234\" -ex gef"'
alias gmulm='echorun "gdb-multiarch -ex \"set arch mips\" -ex \"target remote localhost:1234\" -ex pwn"'
alias gmulr='echorun "gdb-multiarch -ex \"set arch riscv\" -ex \"target remote localhost:1234\" -ex pwn"'
alias gmull='echorun "gdb-multiarch -ex \"target remote localhost:1234\" -ex pwn -ex gep"'
#alias gv='vim ~/.fastgdb/fastgdb'
alias hv='hx ~/.fastgdb/fastgdb'
alias nk="echorun 'python nkp.py'"
alias nkg="echorun 'python nkp.py GDB'"
alias nkga="echorun 'python nkp.py GDB_ATTACH'"
alias nka="echorun 'python nkp.py GDB NOASLR'"
alias nkaa="echorun 'python nkp.py GDB_ATTACH NOASLR'"
alias nkna="echorun 'python nkp.py NOASLR'"
alias nkr="echorun 'python nkp.py REMOTE'"
alias snk="echorun 'strace -f -e execve python nkp.py'"
alias pdock="cd ~/ubuntu-pwndocker"
alias ghs="cd ~/ghidra_scripts"
alias unc="uncompyle6"

# Kernel pwn
alias muc="echorun gcc -E nkp.c -o nkp_tmp.c && echorun musl-gcc nkp_tmp.c -o nkp -static"
alias ru="echorun ./run.sh"
alias rud="echorun ./run.sh DEBUG"

alias repn="echo nka > repwn"
alias repg="echo nka,gmul > repwn"
alias repq="echo nka,gmul,qemu > repwn"
alias noq="sed -i 's/^#FASTGDB_QUEUE:.*/#FASTGDB_QUEUE:/' ~/.gdbinit"

alias lgadz='cat lgadgets | fzf'
alias gadz='cat gadgets | fzf'

alias nocore='echorun rm *.core'
alias c-='echorun rm *.core'
alias mkflag="echo 'FLAGE!' > flag"
alias mkflagt="echo 'FLAGE!' > flag.txt"

# Python scripts
alias psum="python ~/dotfiles/python-scripts/pwn-summary.py"
alias rgb="python ~/dotfiles/python-scripts/rgb.py"
alias rgbl="python ~/dotfiles/python-scripts/rgbl.py"
alias pwnt="python ~/dotfiles/python-scripts/pwnterpreter.py"

# Programs
alias bindiffu="_JAVA_AWT_WM_NONREPARENTING=1 bindiff --ui"

# Disassembly
alias raA="rasm2 -a arm -b 32"
alias rdA="rasm2 -a arm -b 32 -d"
alias raa="rasm2 -a arm -b 64"
alias rda="rasm2 -a arm -b 64 -d"
alias ram="rasm2 -a mips -b 32"
alias rdm="rasm2 -a mips -b 32 -d"
alias rav="rasm2 -a riscv -b 64"
alias rdv="rasm2 -a riscv -b 64 -d"

alias pa="pwn asm"
alias pax="pwn asm -c amd64"
alias paX="pwn asm -c i386"
alias paa="pwn asm -c aarch64"
alias paA="pwn asm -c arm"
alias pam="pwn asm -c mips"
alias pav="pwn asm -c riscv"

alias pd="pwn disasm"
alias pdx="pwn disasm -c amd64"
alias pdX="pwn disasm -c i386"
alias pda="pwn disasm -c aarch64"
alias pdA="pwn disasm -c arm"
alias pdm="pwn disasm -c mips"
alias pdv="pwn disasm -c riscv"

alias polydis="python3 ~/dotfiles/python-scripts/polydis.py"
alias polyasm="python3 ~/dotfiles/python-scripts/polyasm.py"

llnk () {
  expected_libcfile="$(strings $1 | grep '^libc' | head -n1)"
  expected_ldfile="$(strings $1 | grep '^ld-.*' | head -n1)"
  cd lib
  libcfile="$(ls -1 libc-* | head -n1)"
  ldfile="$(ls -1 ld-* | head -n1)"
  ln_libc="ln -s $libcfile $expected_libcfile"
  ln_ld="ln -s $ldfile $expected_ldfile"
  echo "Execute ln cmds? [y/n]"
  echo "$ln_libc"
  echo "$ln_ld"
  read ans
  if [ "$ans" != "${ans#[Yy]}" ]; then
    eval $ln_libc
    eval $ln_ld
  fi
  cd ..
}

paxs () {
  while :; do
    echo -ne "amd64 asm> "
    in_asm=$(bash -c "read c; echo \$c")
    pwn asm -c amd64 "$in_asm"
  done
}

paas () {
  while :; do
    echo -ne "aarch64 asm> "
    in_asm=$(bash -c "read c; echo \$c")
    pwn asm -c aarch64 "$in_asm"
  done
}

nkpsc () {
  ghd "https://github.com/nandkeypull/shellcoding/tree/master/${1}"
  if [[ $(basename $(pwd)) =~ "$1" ]]; then
    cd "$1" && mv * ..
    cd .. && rm -rf "$1"
  fi
}

nkparm () {
  ghd "https://github.com/nandkeypull/armpwn/tree/master/${1}"
  if [[ $(basename $(pwd)) =~ "$1" ]]; then
    cd "$1" && mv * ..
    cd .. && rm -rf "$1"
  fi
}

alias cgx="constgrep -c amd64"
alias cgX="constgrep -c i386"
alias cga="constgrep -c aarch64"
alias cgA="constgrep -c arm"
alias cgm="constgrep -c mips"
alias cgv="constgrep -c riscv"

# Function to auto update ghidra plugin to whatever version your
# ghidra is currently
# edit extension.properties
# zip -r ghidra_10.1.3_PUBLIC_20220214_FindCrypt.zip FindCrypt
ghzup () {
  if [ "$#" -eq 2 ]; then
    local ghzip="$1"
    local version="$2"
    local internal_dir="$(unzip -Z1 $1 | head -n1)"
    unzip $ghzip
    cd $internal_dir
    sed -i "s/version=.*/version=$version/" extension.properties
    cd ..
    zip -r "${ghzip%.*}_new.zip" $internal_dir
  fi
}

rgd() {
  rg "$1" -g '*.{h,hpp}' /usr
}

# TODO: make a shell like shellen to interactively disassemble or assemble
alias s86a="~/dotfiles/expect-scripts/shellen.sc asm x86_32"
alias s86d="~/dotfiles/expect-scripts/shellen.sc dsm x86_32"
alias s64a="~/dotfiles/expect-scripts/shellen.sc asm x86_64"
alias s64d="~/dotfiles/expect-scripts/shellen.sc dsm x86_64"
alias sa64a="~/dotfiles/expect-scripts/shellen.sc asm arm64"
alias sa64d="~/dotfiles/expect-scripts/shellen.sc dsm arm64"

# TODO: tool to convert to string and do rev
# __template[4] = 0x58585858;
# *__template = 0x706d742f;
# __template[1] = 0x6e6f732f;
# __template[2] = 0x69665f67;
# __template[3] = 0x582d656c;

# push    0x67616c66 => galf
# push    0x2f77726f => /wro
# push    0x2f656d6f => /emo
# push    0x682f2f2f => h///

echorun () {
  echo "$@"; eval "$@"
}

sshkr () {
    echorun sshpass -p guest \
    ssh $(cat $HOME/pwnable_kr/cur_kr)@pwnable.kr -p2222
}

setkr () {
    echo "$1" > $HOME/pwnable_kr/cur_kr
}

getkr() {
    cat $HOME/pwnable_kr/cur_kr
}

scpkr () {
    local prob=$(cat $HOME/pwnable_kr/cur_kr)
    echorun sshpass -p guest scp -P2222 ${prob}@pwnable.kr:/home/${prob}/* .
}

pwndock () {
    if [ "$#" -ne 1 ]; then
        echo "usage: pwndock <name>"
    else
        docker run -d \
                --rm \
                --privileged \
                -h "$1" \
                --name "$1" \
                -v $(pwd):/ctf/"$1" \
                -p 23946:23946 \
                --cap-add=SYS_PTRACE \
                skysider/pwndocker
    fi
}

dcp() {
    local container=${1:-$(docker ps -aql)}
    echorun "docker cp ~/.gdbinit $container:/root"
    echorun "docker cp ~/.gdb_history $container:/root"
    echorun "docker cp ~/dotfiles/alias/.gdb_pwn_funcs $container:/root"
    #echorun "docker cp ~/dotfiles/tmux/.tmux.conf $container:/root"
    echorun "docker cp ~/dotfiles/alias/.pwn_funcs $container:/root"
    echorun "docker cp ~/HeapLAB/.glibc $container:/root/HeapLAB/.glibc"
}

dkex() {
    if [ "$#" -ne 1 ]; then
        echo "usage: dkex <container id>"
    else
        echorun "docker exec -it $1 /bin/bash"
    fi
}

ropg () {
    echorun "ROPgadget --binary $1 > gadgets"
}

# Run checks on the pwn binary
pck () {
    # TODO: colorize shell output
    echorun "file $1"
    echo ""
    echorun "pwn checksec $1"
    echo ""
    # check for existence of lib file
    echorun "ldd $1"
    echo ""
    lver

    python ~/dotfiles/python-scripts/pwn-summary.py "$1" 1>/dev/null 2>&1
}

# Get libc version
lver () {
    local lfile=${1:-"libc*"}
    # echorun "./$lfile --version | head -n1"
    echorun "strings $lfile | grep 'release version' | head -n1"
}

bsh () {
    echorun "strings -tx $1 | grep /bin/sh"
}

cstrings () {
    local cwords="blake|aes|sha256|sha512|chacha|RC4|salsa|tea|'expand 16-byte'|'expand 32-byte"
    strings "$1" | grep -i --color=always -E $cwords
}

cpiox () {
    local cpioname="${1:-initramfs.cpio.gz}"
    echorun mkdir initramfs && \
    echorun cd initramfs && \
    echorun "cp ../${cpioname} ." && \
    echorun "gunzip ./${cpioname}" && \
    echorun "cpio -idm < ./${cpioname%.*}" && \
    echorun "rm ${cpioname%.*}"
}

cpio+() {
    # rebuild initramfs
    pushd fs
    find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../initramfs.cpio.gz
    popd
}

muserfault() {
    cp -r /usr/include/x86_64-linux-gnu/asm .
    cp -r /usr/include/asm-generic .
    mkdir linux
    for header in posix_types.h stddef.h types.h userfaultfd.h; do
        cp /usr/include/linux/$header ./linux
    done
}

# Extract region from binary file
# Sample usage:
#     crunch humbug.bin 0x1200 0x1400
#
# e.g. Get region 0x1200 to 0x1400 from file
#      tail -c +4609 file | head -c

# Extract region from binary file
# Sample usage:
#     crunch crash.bin 0x1200 0x1400
crunch() {
    if [ "$#" -ne 3 ]; then
        echo "usage: crunch <file.bin> <start address> <end address>"
        echo ""
        echo "example: crunch myfile.bin 0x1000 0x2000"
    else
        local file="$1"
        local start_addr="$2"
        local end_addr="$3"
        local difference="$(($end_addr - $start_addr))"
        echorun_conf "tail -c +$(($start_addr+1)) $file | head -c $difference > ${file}_out"
    fi
}

# Sample usage:
# Get the first 0x200 bytes
# munch head crash.bin 0x200

# Get everything from 0x200 onwards
# munch tail crash.bin 0x200
munch() {
    if [ "$#" -ne 3 ]; then
        echo "usage: munch <(head|tail)> <file.bin> <offset>"
        echo ""
        echo "example: munch head myfile.bin 0x100"
    else
        local op="$1"
        local file="$2"
        local offset="$3"
        case "$op" in
            "head") echorun_conf "head -c $((offset)) $file > ${file}_out" ;;
            "tail") echorun_conf "tail -c +$((offset+1)) $file > ${file}_out" ;;
            *)
            echo "usage: munch <(head|tail)> <file.bin> <offset>"
            echo ""
            echo "example: munch head myfile.bin 0x100" ;;
        esac
    fi
}

quickrop () {
    # TODO: allow for 32-bit gagdets
    cat gadgets | grep ': pop rdi ; ret$'
    cat gadgets | grep ': pop rsi ; ret$'
    cat gadgets | grep ': pop rdx ; ret$'
    cat gadgets | grep ': pop rax ; ret$'
    cat gadgets | grep ': ret$'
    cat gadgets | grep ': syscall$'

    # Write memory gadgets
    echo ""
    cat gadgets | grep ": mov dword ptr \[e..\], e.. ; ret"
    cat gadgets | grep ": mov qword ptr \[r..\], r.. ; ret"

python - << EOF
import subprocess
def make_pycode(output, sub_dict):
    lvalue = ""
    output = str(output).lstrip("b'")[:-3]
    for line in output.split("\\n"):
        # print("line is ", line)
        for key in sub_dict:
            if key in line:
                lvalue = sub_dict[key]
                break
        print(lvalue + " = " + line.replace(":", "#"))

d = {
    "pop rdi":"pop_rdi",
    "pop rsi":"pop_rsi",
    "pop rdx":"pop_rdx",
    "mov":"write_mem",
    "ret":"ret",
    "syscall":"syscall",
}
make_pycode(subprocess.check_output("cat gadgets | grep ': pop rdi ; ret$'", shell=True), d)
make_pycode(subprocess.check_output("cat gadgets | grep ': pop rsi ; ret$'", shell=True), d)
make_pycode(subprocess.check_output("cat gadgets | grep ': pop rdx ; ret$'", shell=True), d)
make_pycode(subprocess.check_output("cat gadgets | grep ': pop rax ; ret$'", shell=True), d)
make_pycode(subprocess.check_output("cat gadgets | grep ': ret$'", shell=True), d)
make_pycode(subprocess.check_output("cat gadgets | grep ': syscall$'", shell=True), d)
make_pycode(subprocess.check_output("cat gadgets | grep ': mov qword ptr \[r..\], r.. ; ret'", shell=True), d)
EOF
}

1g () {
    one_gadget $(ldd "$1" | grep libc.so | cut -d' ' -f3)
}

chks () {
    pwn checksec "$1"
}

bstr () {
    hexnum=$1
    echo $hexnum
    python -c "
# hexnum = '%x' % $1
hexnum = $1.to_bytes(4)
print(hexnum)
# hexlist = [r'\x' + hexnum[i:i+2].zfill(2) for i in range(0, len(hexnum), 2)]
# hexlist = hexlist[::-1]
# print(hexlist)"
#'\\x'.join(hexlist)"
}

# https://stackoverflow.com/questions/13261109/python-string-of-binary-escape-sequences-as-literal
